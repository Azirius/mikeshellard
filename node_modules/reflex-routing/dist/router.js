var Router = (function () {
  'use strict';

  var babelHelpers = {};
  babelHelpers.typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
  };

  babelHelpers.classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  babelHelpers.createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  babelHelpers;

  /**
   * Checkes to see if value is empty
   * @param  {mixed} uri URI to check
   * @return {boolean}
   */
  function empty(value) {
      if ((typeof value === 'undefined' ? 'undefined' : babelHelpers.typeof(value)) == 'object') {
          for (var currentValue in value) {
              if (!!value[currentValue]) {
                  return false;
              }
          }

          return true;
      }

      return !value;
  }

  /**
   * Key exists in array
   * @param  {string} key   Key to lookup
   * @param  {array}  array Object to look in
   * @return {boolean}       
   */
  function exists(key, array) {
      return is_object(array) && key in array;
  }

  /**
   * Extend an object passed in
   * @param  {object} to   Object to extend
   * @param  {object} from Extend from this
   * @return {object}      
   */
  function extend(to, from) {
      for (var key in from) {
          to[key] = from[key];
      }
      return to;
  }

  /**
   * Assert something is an array
   * @param  {mixed}   thing      Thing to check
   * @return {Boolean}            
   */
  function is_array(thing) {
      return is_type(thing, 'array');
  }

  /**
   * Assert something is an object
   * @param  {mixed}   thing      Thing to check
   * @return {Boolean}            
   */
  function is_object(thing) {
      return is_type(thing, 'object');
  }

  /**
   * Assert something is something
   * @param  {mixed}   thing      Thing to check
   * @param  {string}  assertThis Type to check against
   * @return {Boolean}            
   */
  function is_type(thing, assertThis) {
      var typeString = Object.prototype.toString.call(thing);

      return typeString.toLowerCase() === '[object ' + assertThis.toLowerCase() + ']';
  }

  /**
   * Trim left of given string
   * @param  {string} string   String to trim
   * @param  {string} charlist Optional character list
   * @return {string}          
   */
  function ltrim(string, charlist) {
      charlist = charlist || 's';
      return string.replace(new RegExp('^[' + charlist + ']+'), '');
  };

  var defaultConfig = {
    /**
     * Default route URI
     * @type {String}
     */
    defaultURI: 'home',

    /**
     * Patterns to loop through for URI matching
     * @type {Object}
     */
    patterns: {
      'escape': [/[\-{}\[\]+?.,\\\^$|#\s]/g, '\\$&'],
      'optional': [/\((.*?)\)/g, '(?:$1)?'],
      'named': [/(\(\?)?:\w+/g, function (match, optional) {
        return optional ? match : '([^/?]+)';
      }],
      'greedy': [/\*\w+/g, '([^?]*?)']
    }
  };

  var Route = function () {
      /**
       * Route
       *
       * @param {string} uri    Uri to route
       * @param {object} router Router instance
       */

      function Route(uri, regex, router) {
          babelHelpers.classCallCheck(this, Route);

          this.uri = uri;
          this.regex = regex;
          this.router = router;
          this.callbacks = new Array();
          this.parameters = new Array();
      }

      /**
       * Launch this route
       * @return {Array}            
       */


      babelHelpers.createClass(Route, [{
          key: 'launch',
          value: function launch() {
              var _this = this;

              return this.callbacks.map(function (callback) {
                  return callback.apply({}, _this.arguments);
              });
          }

          /**
           * Add a callback to this route
           * @param {callable} callback Callback being added
           * @return {Route}
           */

      }, {
          key: 'add',
          value: function add(callback) {
              var _this2 = this;

              if (is_array(callback)) {
                  callback.forEach(function (callable) {
                      return _this2.add(callable);
                  });

                  return;
              }

              this.callbacks.push(callback);

              return this;
          }

          /**
           * Flush all callbacks
           * @return {Route} 
           */

      }, {
          key: 'flush',
          value: function flush() {
              this.callbacks = new Array();

              return this;
          }

          /**
           * Does the compiled route match to the passed in uri?
           * @param  {string} uri URI to check against
           * @return {boolean}
           */

      }, {
          key: 'matches',
          value: function matches(uri) {
              var result = this.regex.exec(uri);

              if (result) {
                  this.parameters = result.slice(1);
                  return true;
              }

              return false;
          }

          /**
           * Get parameters for the route from parameter matching done previously
           * @return {array} 
           */

      }, {
          key: 'arguments',
          get: function get() {
              var _this3 = this;

              return this.parameters.map(function (parameter, i) {
                  if (i === _this3.parameters.length - 1) {
                      return parameter || null;
                  }

                  return parameter ? decodeURIComponent(parameter) : null;
              });
          }
      }]);
      return Route;
  }();

  var Router = function () {
      /**
       * Constructor
       * @param  {Object} mappables Routes to map
       * @param  {Object} config    Configuration
       * @return {Router}           
       */

      function Router() {
          var mappables = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
          var config = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
          babelHelpers.classCallCheck(this, Router);

          this.routes = {};
          this.config = extend(defaultConfig, config);
          this.previousUri = '';
          this.beforeQueue = new Array();
          this.afterQueue = new Array();
          this.current = null;
          this.routeCount = 0;

          if (is_object(mappables)) {
              this.map(mappables);
          }
      }

      /**
       * Turn a route string into a regex instance
       * @param  {string} route Route to transform
       * @return {RegExp}
       */


      babelHelpers.createClass(Router, [{
          key: 'routeToRegex',
          value: function routeToRegex(route) {
              for (var pattern in this.patterns) {
                  var replacement = this.patterns[pattern];

                  route = route.replace(replacement[0], replacement[1]);
              }

              return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
          }

          /**
           * Get patterns
           * @return {array}
           */

      }, {
          key: 'before',


          /**
           * Add a before callback
           * @param  {callable} callable Callable
           * @return {Router}          
           */
          value: function before(callable) {
              this.beforeQueue.push(callable);

              return this;
          }

          /**
           * Add an after callback
           * @param  {callable} callable Callable
           * @return {Router}          
           */

      }, {
          key: 'after',
          value: function after(callable) {
              this.afterQueue.push(callable);

              return this;
          }

          /**
           * Launch a route
           * @param  {string} uri URI to search and route
           * @param {boolean} fire Automatically fire the route?
           * @return {Route|Array|null}
           */

      }, {
          key: 'route',
          value: function route(uri) {
              var _this = this;

              var fire = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

              var route = this.find(uri);
              var response = null;

              this.routeCount++;
              this.beforeQueue.map(function (callable) {
                  return callable(_this, route, uri);
              });
              this.current = route;

              if (route && fire) {
                  response = route.launch();
              }

              response = this.afterQueue.map(function (callable) {
                  return callable(_this, route, uri, response);
              });

              if (empty(response)) {
                  response = null;
              }

              return fire ? response : route;
          }

          /**
           * Redirects to another route without launching before/after callbacks
           * @param  {string} uri URI to search and route
           * @param {boolean} fire Automatically fire the route?
           * @return {Route|Array|null}     
           */

      }, {
          key: 'redirect',
          value: function redirect(uri) {
              var fire = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

              var route = this.find(uri);
              this.current = route;

              if (route && fire) {
                  return route.launch();
              }

              return route;
          }

          /**
           * Find a URI, compiled or otherwise
           * @param  {string} uri URI to hunt
           * @return {Route|null}     
           */

      }, {
          key: 'find',
          value: function find(uri) {
              if (empty(uri)) {
                  uri = this.defaultURI;
              }

              uri = this.normalize(uri);

              for (var routeURI in this.routes) {
                  var route = this.routes[routeURI];

                  if (route.matches(uri)) {
                      return route;
                  }
              }

              return null;
          }

          /**
           * Normalize the value to a string
           * @param  {mixed} value Value to normalize
           * @return {string}       
           */

      }, {
          key: 'normalize',
          value: function normalize(value) {
              return empty(value) ? '' : '/' + ltrim(new String(value), '/');
          }

          /**
           * Map routes
           * @param  {object} routes Routes to map
           * @return {Router}        
           */

      }, {
          key: 'map',
          value: function map(routes) {
              for (var route in routes) {
                  var thisUri = this.previousUri;

                  this.previousUri += this.normalize(route);

                  if (is_object(routes[route])) {
                      // Further down the rabbit hole...
                      this.map(routes[route]);
                  } else {
                      this.add(this.previousUri, routes[route]);
                  }

                  this.previousUri = thisUri;
              }

              this.previousUri = '';

              return this;
          }

          /**
           * Create a new instance of Route or a previous one
           * @param  {string} uri URI to generate route for
           * @return {Route}           
           */

      }, {
          key: 'routeFactory',
          value: function routeFactory(uri) {
              uri = this.normalize(uri);

              if (exists(uri, this.routes)) {
                  return this.routes[uri];
              }

              return this.routes[uri] = new Route(uri, this.routeToRegex(uri), this);
          }

          /**
           * Add a route
           * @param {string}   uri      URI to map to
           * @param {callable} callable Callable
           * @return {Router}
           */

      }, {
          key: 'add',
          value: function add(uri, callable) {
              var route = this.routeFactory(uri);

              route.add(callable);

              return this;
          }
      }, {
          key: 'patterns',
          get: function get() {
              return this.config.patterns;
          }

          /**
           * Get the 'default' route uri
           * @return {string} 
           */

      }, {
          key: 'defaultURI',
          get: function get() {
              return this.config.defaultURI;
          }
      }, {
          key: 'isInitial',
          get: function get() {
              return 1 === this.routeCount;
          }
      }]);
      return Router;
  }();

  return Router;

}());